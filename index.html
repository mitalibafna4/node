<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KK Wagh Engineering College</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="courses.html">Courses</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <section id="home">
      <h2>Welcome to KK Wagh Engineering College</h2>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed vel felis orci. Fusce non ultricies metus, nec finibus felis. Nunc in enim sed erat rhoncus consequat. Mauris lacinia leo ac ultrices rutrum.</p>
      <p>Vestibulum vitae efficitur lorem. Suspendisse potenti. Quisque et ligula auctor, efficitur ligula sed, varius neque. Morbi varius semper dolor nec fringilla. Praesent porta eros vitae vulputate consectetur.</p>
    </section>
    <section id="about">
      <h2>About KK Wagh Engineering College</h2>
      <p>KK Wagh Engineering College is a renowned institution offering a wide range of engineering programs. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc cursus massa ut odio maximus consequat. Mauris tincidunt est in nunc vulputate malesuada. Phasellus ac fringilla metus.</p>
      <p>Donec eu est justo. Duis nec luctus tortor. Praesent convallis, tellus nec luctus semper, mi massa feugiat mauris, eget tincidunt erat neque sed enim. Pellentesque facilisis tellus velit, auctor ultricies lectus pellentesque et.</p>
    </section>
    <section id="courses">
      <h2>Courses Offered</h2>
      <ul>
        <li>Computer Science Engineering</li>
        <li>Mechanical Engineering</li>
        <li>Electrical Engineering</li>
        <li>Civil Engineering</li>
      </ul>
    </section>
    <section id="contact">
      <h2>Contact Us</h2>
      <p>KK Wagh Engineering College<br>
      Address: ABC Road, XYZ City<br>
      Phone: 123-456-7890<br>
      Email: info@kkwaghcollege.com</p>
    </section>
  </main>
  <footer>
    <p>&copy; 2023 KK Wagh Engineering College</p>
  </footer>
  <script src="script.js"></script>
</body>
</html>
<!--ASSIGNMENT 1: Implement multi-threaded client/server Process communication using RMI. 
MathServerIntf.java:
// Yeh ek interface hai jo Remote interface ko extend karti hai.
// Isme ek method hai jo do numbers ka addition karega aur RemoteException throw karega agar koi error aata hai.
import java.rmi.*;
public interface MathServerIntf extends Remote {
    double add(double d1, double d2) throws RemoteException;
    double subtract(double d1, double d2) throws RemoteException;
    double multiply(double d1, double d2) throws RemoteException;
    double divide(double d1, double d2) throws RemoteException;
}
MathServerImpl.java:
// Yeh ek class hai jo Remote interface ko implement karti hai.
// Isme server-side logic hota hai jo client se received numbers ka addition karta hai.
import java.rmi.*;
import java.rmi.server.*;
public class MathServerImpl extends UnicastRemoteObject implements MathServerIntf {
    public MathServerImpl() throws RemoteException {
    }


    @Override
    public double add(double d1, double d2) throws RemoteException {
        return d1 + d2;
    }


    @Override
    public double subtract(double d1, double d2) throws RemoteException {
        return d1 - d2;
    }


    @Override
    public double multiply(double d1, double d2) throws RemoteException {
        return d1 * d2;
    }


    @Override
    public double divide(double d1, double d2) throws RemoteException {
        if (d2 == 0) {
            throw new RemoteException("Division by zero not allowed");
        }
        return d1 / d2;
    }
}
MathClient.java:
// Yeh ek client-side program hai jo server se connect hota hai aur numbers ka addition karvata hai.
import java.rmi.*;
import java.util.Scanner;


public class MathClient {
    public static void main(String args[]) {
        if (args.length < 1) {
            System.out.println("Usage: java MathClient <server_url>");
            return;
        }


        String serverURL = "rmi://" + args[0] + "/MathServer";


        try {
            MathServerIntf mathServer = (MathServerIntf) Naming.lookup(serverURL);
            Scanner scanner = new Scanner(System.in);


            System.out.print("Enter the first number: ");
            double num1 = scanner.nextDouble();
            System.out.print("Enter the second number: ");
            double num2 = scanner.nextDouble();


            System.out.println("\nPerforming mathematical operations:");
            System.out.println("-------------------------------");


            double addResult = mathServer.add(num1, num2);
            double subtractResult = mathServer.subtract(num1, num2);
            double multiplyResult = mathServer.multiply(num1, num2);
            double divideResult = mathServer.divide(num1, num2);


            System.out.println("Addition result: " + addResult);
            System.out.println("Subtraction result: " + subtractResult);
            System.out.println("Multiplication result: " + multiplyResult);
            System.out.println("Division result: " + divideResult);


            scanner.close();
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        }
    }
}
MathServer.java:
// Yeh server program hai jo AddServerImpl class ko bind karta hai aur RMI registry ko use karta hai.
import java.rmi.*;


public class MathServer {
    public static void main(String args[]) {
        try {
            MathServerImpl mathServerImpl = new MathServerImpl();
            Naming.rebind("MathServer", mathServerImpl);
            System.out.println("MathServer is ready.");
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        }
    }
}
javac MathServer.java MathServerImpl.java MathServerIntf.java MathClient.java
start rmiregistry
java MathServer
javac MathClient.java
java MathClient localhost
RMI (Remote Method Invocation) ka matlab hota hai "door ke method invocation." Yeh ek Java programming concept hai jo allow karta hai ki ek Java program dusre Java program ke methods ko remote taur par invoke kar sake, matlab ek machine se dusri machine ke methods ko call kar sake.


Detail mein, RMI ka istemal karte waqt hum:


Remote Interface Define Karte Hai: Interface mein remote methods ko define karte hai jo dusre machines par invoke ho sakte hai.


Server-Side Logic Implement Karte Hai: Ek server-side class mein remote interface ko implement karte hai. Isme server ke methods ka logic hota hai jo client se received requests ko process karte hai.


Client-Side Logic Implement Karte Hai: Ek client-side program mein server se communication ke logic ko define karte hai. Isme client server se request bhejta hai aur response ko process karta hai.


Server Ko Bind Karte Hai: Server ko ek unique name se RMI registry mein bind karte hai taki clients use locate kar sake.


Client Aur Server Ke Beech Communication Establish Karte Hai: Client server se connect ho kar remote methods ko call karta hai. Server uss request ko process karta hai aur response ko client ko bhejta hai.

Exception Handling: RMI mein exception handling bhi important hota hai, jaise ki network errors ya server-side exceptions ke liye.


Distributed Computing Ke Liye Use Hota Hai: RMI distributed computing ko support karta hai, jisme multiple machines ek saath work karke tasks ko complete karte hai.
AddServerIntf.java: Is file mein ek interface define kiya gaya hai jo Remote interface ko extend karta hai. Isme ek add method hai jo do numbers ka addition karta hai aur RemoteException throw karta hai agar koi error aata hai.


AddServerImpl.java: Yeh file AddServerIntf interface ko implement karti hai. Isme server-side logic hai jo client se received numbers ka addition karta hai. Is file mein ek constructor hai jo RemoteException throw karta hai aur add method hai jo actual addition logic implement karta hai.


AddClient.java: Yeh ek client-side program hai jo server se connect hota hai aur numbers ka addition karvata hai. Isme main method hai jo command line arguments se numbers ko parse karta hai aur phir server par add method ko call karke result print karta hai.


AddServer.java: Yeh ek server program hai jo AddServerImpl class ko bind karta hai aur RMI registry ka use karta hai. Isme server ek remote object create karta hai jo client se communication ke liye use hota hai.
ASSIGNMENT 4: Implement Berkeley algorithm for clock synchronization. 
import socket  # Socket module ko import kiya hai
import datetime  # Datetime module ko import kiya hai
import time  # Time module ko import kiya hai


def send_time(host='127.0.0.1', port=8080):  # send_time function define kiya gaya hai jisme default host aur port diya gaya hai
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:  # Socket object create kiya gaya hai
        client.connect((host, port))  # Client socket ko server se connect kiya gaya hai


        while True:  # Hamesha chalne wala loop
            current_time = datetime.datetime.now()  # Current time ko fetch kiya gaya hai
            client.send(str(current_time).encode())  # Server ko current time send kiya gaya hai
            print(f"Sent current time to server: {current_time}")  # Current time ko print kiya gaya hai
            time.sleep(5)  # 5 seconds ka wait kiya gaya hai


if __name__ == '__main__':  # Program ka starting point
    send_time()  # send_time function ko call kiya gaya hai







SERVER.PY

import socket  # Import kar rahe hain socket module
import threading  # Import kar rahe hain threading module
import datetime  # Import kar rahe hain datetime module


clients = {}  # Dictionary ko client ki jaankari store karne ke liye use kiya gaya hai


def handle_client(conn, addr):  # handle_client function define kiya gaya hai jo client ki request ko handle karega
    while True:  # Hamesha chalne wala loop
        try:  # Try block start kiya gaya hai
            data = conn.recv(1024).decode()  # Client se data receive kiya gaya hai
            if data:  # Agar data hai toh
                clients[addr] = datetime.datetime.strptime(data, "%Y-%m-%d %H:%M:%S.%f")  # Client ka time store kiya gaya hai
        except:  # Exception ko handle kiya gaya hai
            break  # Loop se bahar nikala gaya hai


def clock_server(port=8081):  # clock_server function define kiya gaya hai jo server ko start karega
    with socket.socket() as server:  # Socket create kiya gaya hai
        server.bind(('', port))  # Server ko bind kiya gaya hai port number ke saath
        server.listen()  # Server ne sunna start kiya hai


        print("Clock server started on port:", port)  # Print statement hai jo server ka port number print karega


        while True:  # Hamesha chalne wala loop
            conn, addr = server.accept()  # Client se connection accept kiya gaya hai
            threading.Thread(target=handle_client, args=(conn, addr)).start()  # Naya thread create kiya gaya hai handle_client function ke liye


if __name__ == '__main__':  # Program ka starting point
    clock_server()  # clock_server function ko call kiya gaya hai





ASSIGNMENT 5: Implement token ring based mutual exclusion algorithm. 
import java.util.Scanner;


class Tring {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);


        System.out.print("Enter the number of nodes: ");
        int n = sc.nextInt();


        int token = 0;


        for (int i = 0; i < n; i++)
            System.out.print(" " + i);
        System.out.println(" " + 0);


        try {
            while (true) {
                System.out.print("Enter sender: ");
                int s = sc.nextInt();
                System.out.print("Enter receiver: ");
                int r = sc.nextInt();
                System.out.print("Enter Data: ");
                String d = sc.next();


                System.out.print("Token passing:");


                for (int i = token, j = token; (i % n) != s; i++, j = (j + 1) % n) {
                    System.out.print(" " + j + "->");
                }
                System.out.println(" " + s);


                System.out.println("Sender " + s + " sending data: " + d);


                for (int i = (s + 1) % n; i != r; i = (i + 1) % n) {
                    System.out.println("Data " + d + " forwarded by " + i);
                }
                System.out.println("Receiver " + r + " received data: " + d);
                token = s;
            }
        } catch (Exception e) {
            System.out.println("Error occurred: " + e.getMessage());
        }
    }
}
================================================================================
PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main> cd Assign5    
PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign5> javac Tring.java
PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign5>
PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign5> java Tring.java
Enter the number of nodes: 5
 0 1 2 3 4 0
Enter sender: 2          
Enter receiver: 4
Enter Data: Hello
Token passing: 0-> 1-> 2
Sender 2 sending data: Hello
Data Hello forwarded by 3
Receiver 4 received data: Hello
Enter sender:

ASSIGNMENT 6:  Implement Bully and Ring algorithm for leader election. 

BULLY

import java.util.*;


public class Bully {
    int coordinator;
    int max_processes;
    boolean processes[];




    public Bully(int max) {
        max_processes = max;
        processes = new boolean[max_processes];
        coordinator = max;


        System.out.println("Creating processes..");
        for(int i = 0; i < max; i++) {
            processes[i] = true;
            System.out.println("P"+ (i+1) + " created");
        }
        System.out.println("Process P" + coordinator + " is the coordinator");


    }
    void displayProcesses() {
        for(int i = 0; i < max_processes; i++) {
            if(processes[i]) {
                System.out.println("P" + (i+1) + " is up");
            } else {
                System.out.println("P" + (i+1) + " is down");
            }
        }
        System.out.println("Process P" + coordinator + " is the coordinator");
    }


    void upProcess(int process_id) {
        if(!processes[process_id - 1]) {
            processes[process_id - 1] = true;
            System.out.println("Process " + process_id + " is now up.");
        } else {
            System.out.println("Process " + process_id + " is already up.");
        }
    }


    void downProcess(int process_id) {
        if(!processes[process_id - 1]) {
            System.out.println("Process " + process_id + " is already down.");
        } else {
            processes[process_id - 1] = false;
            System.out.println("Process " + process_id + " is down.");
        }
    }


    void runElection(int process_id) {
        coordinator = process_id;
        boolean keepGoing = true;


        for(int i = process_id; i < max_processes && keepGoing; i++) {
            System.out.println("Election message sent from process " + process_id + " to process " + (i+1));


            if(processes[i]) {
                keepGoing = false;
                runElection(i + 1);
            }
        }
    }


    public static void main(String args[]) {
        Bully bully = null;
        int max_processes = 0, process_id = 0;
        int choice = 0;
        Scanner sc = new Scanner(System.in);


        while(true) {
            System.out.println("Bully Algorithm");
            System.out.println("1. Create processes");
            System.out.println("2. Display processes");
            System.out.println("3. Up a process");
            System.out.println("4. Down a process");
            System.out.println("5. Run election algorithm");
            System.out.println("6. Exit Program");
            System.out.print("Enter your choice:- ");
            choice = sc.nextInt();


            switch(choice) {
                case 1:
                    System.out.print("Enter the number of processes:- ");
                    max_processes = sc.nextInt();
                    bully = new Bully(max_processes);
                    break;
                case 2:
                    bully.displayProcesses();
                    break;
                case 3:
                    System.out.print("Enter the process number to up:- ");
                    process_id = sc.nextInt();
                    bully.upProcess(process_id);
                    break;
                case 4:
                    System.out.print("Enter the process number to down:- ");
                    process_id = sc.nextInt();
                    bully.downProcess(process_id);
                    break;
                case 5:
                    System.out.print("Enter the process number which will perform election:- ");
                    process_id = sc.nextInt();
                    bully.runElection(process_id);
                    bully.displayProcesses();
                    break;
                case 6:
                    System.exit(0);
                    break;
                default:
                    System.out.println("Error in choice. Please try again.");
                    break;
            }
        }
    }
}





RING

import java.util.*;


public class Ring {
    int max_processes;
    int coordinator;
    boolean processes[];
    ArrayList<Integer> pid;


    public Ring(int max) {
        coordinator = max;
        max_processes = max;
        pid = new ArrayList<Integer>();
        processes = new boolean[max];


        for(int i = 0; i < max; i++) {
            processes[i] = true;
            System.out.println("P" + (i+1) + " created.");
        }
        System.out.println("P" + (coordinator) + " is the coordinator");
    }


    void displayProcesses() {
        for(int i = 0; i < max_processes; i++) {
            if(processes[i])
                System.out.println("P" + (i+1) + " is up.");
            else
                System.out.println("P" + (i+1) + " is down.");
        }  
        System.out.println("P" + (coordinator) + " is the coordinator");
    }


    void upProcess(int process_id) {
        if(!processes[process_id-1]) {
            processes[process_id-1] = true;
            System.out.println("Process P" + (process_id) + " is up.");
        } else {
            System.out.println("Process P" + (process_id) + " is already up.");
        }
    }


    void downProcess(int process_id) {
        if(!processes[process_id-1]) {
            System.out.println("Process P" + (process_id) + " is already down.");
        } else {
            processes[process_id-1] = false;
            System.out.println("Process P" + (process_id) + " is down.");
        }
    }


    void displayArrayList(ArrayList<Integer> pid) {
        System.out.print("[ ");
        for(Integer x : pid) {
            System.out.print(x + " ");
        }
        System.out.print(" ]\n");
    }


    void initElection(int process_id) {
        if(processes[process_id-1]) {
            pid.add(process_id);


            int temp = process_id;


            System.out.print("Process P" + process_id + " sending the following list:- ");
            displayArrayList(pid);


            while(temp != process_id - 1) {
                if(processes[temp]) {
                    pid.add(temp+1);
                    System.out.print("Process P" + (temp + 1) + " sending the following list:- ");
                    displayArrayList(pid);
                }
                temp = (temp + 1) % max_processes;
            }
            coordinator = Collections.max(pid);
            System.out.println("Process P" + process_id + " has declared P" + coordinator + " as the coordinator");
            pid.clear();
        }
    }


    public static void main(String args[]) {
        Ring ring = null;
        int max_processes = 0, process_id = 0;
        int choice = 0;
        Scanner sc = new Scanner(System.in);


        while(true) {
            System.out.println("Ring Algorithm");
            System.out.println("1. Create processes");
            System.out.println("2. Display processes");
            System.out.println("3. Up a process");
            System.out.println("4. Down a process");
            System.out.println("5. Run election algorithm");
            System.out.println("6. Exit Program");
            System.out.print("Enter your choice:- ");
            choice = sc.nextInt();


            switch(choice) {
                case 1:
                    System.out.print("Enter the total number of processes:- ");
                    max_processes = sc.nextInt();
                    ring = new Ring(max_processes);
                    break;
                case 2:
                    ring.displayProcesses();
                    break;
                case 3:
                    System.out.print("Enter the process to up:- ");
                    process_id = sc.nextInt();
                    ring.upProcess(process_id);
                    break;
                case 4:
                    System.out.print("Enter the process to down:- ");
                    process_id = sc.nextInt();
                    ring.downProcess(process_id);
                    break;
                case 5:
                    System.out.print("Enter the process which will initiate election:- ");
                    process_id = sc.nextInt();
                    ring.initElection(process_id);
                    break;
                case 6:
                    System.exit(0);
                    break;
                default:
                    System.out.println("Error in choice. Please try again.");
                    break;
            }
        }
    }
}


PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign6> javac Bully.java
PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign6> java Bully      
Bully Algorithm
1. Create processes
2. Display processes
3. Up a process
4. Down a process
5. Run election algorithm
6. Exit Program
Enter your choice:- 


PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign6> javac Ring.java
PS C:\Users\mital\Downloads\BE-IT-DS-main\BE-IT-DS-main\Assign6> java Ring
Ring Algorithm
1. Create processes
2. Display processes
3. Up a process
4. Down a process
5. Run election algorithm
6. Exit Program
Enter your choice:-





-->
<!---->
